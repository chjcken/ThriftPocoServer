// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

#include "Poco/Logger.h"
#include "Poco/ConsoleChannel.h"
#include "Poco/AutoPtr.h"

#include <iostream>
#include <stdexcept>
#include <sstream>
#include <Poco/FileChannel.h>
#include <Poco/FormattingChannel.h>
#include <Poco/PatternFormatter.h>
#include <Poco/Util/PropertyFileConfiguration.h>
#include <Poco/Util/Application.h>
#include <Poco/Util/HelpFormatter.h>
#include <Poco/Util/Option.h>
#include <Poco/Util/OptionSet.h>
#include <Poco/Util/IntValidator.h>

#include "Counter.h"

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;
using namespace apache::thrift::concurrency;

using Poco::Logger;
using Poco::ConsoleChannel;
using Poco::FileChannel;
using Poco::AutoPtr;
using Poco::FormattingChannel;
using Poco::PatternFormatter;
using Poco::Util::PropertyFileConfiguration;
using Poco::Util::Application;
using Poco::Util::Option;
using Poco::Util::OptionSet;
using Poco::Util::HelpFormatter;
using Poco::Util::OptionCallback;
using Poco::Util::IntValidator;

using boost::shared_ptr;
using namespace std;
using namespace  counterService;




class CounterHandler : public CounterIf {
    
static const int PUTTYPE_REG = 1;
static const int PUTTYPE_LOG = 2;
static const int GETTYPE_MINE = 1;
static const int GETTYPE_TOTAL = 2;
ServerFigure serv;// = ServerFigure();
static const int nul = -1;

 public:
   static Logger& logger;
  CounterHandler() {
    // Your initialization goes here
      serv = ServerFigure();
  }
  
  int findAccountById(const std::string& id){

      int siz = (serv.listAccount).size();
      for (int i = 0; i< (siz); i++){
          if ((serv.listAccount[i]).id.compare(id) == 0)
              return i;                  
      }
      
      return nul;
  }

  bool put(const std::string& id, const int putType) {
    // Your implementation goes here
    int acc = findAccountById(id);
      if (putType == PUTTYPE_REG){
          logger.information("register user " + id);
          if (acc != nul)
              return false;
          else {
              //serv.listAccount.insert(0, acc);
              Account a = Account();
              a.__set_id(id);
              serv.listAccount.push_back(a);
              inc(id, 1);
              return true;
          }
      }
      else {
          logger.information("log in user " + id);
          if (acc == nul)
              return false;
          else {
              inc(id, 1);
              return true;
          }
      }
  }

  int getTotal() {
    // Your implementation goes here
    logger.information("getTotal() is called");
    return serv.totalVisitor;
  }

  int get(const std::string& id, const int getType) {
    // Your implementation goes here
    
    int index = findAccountById(id);
      if (index != nul){
          if (getType == GETTYPE_MINE){
              logger.information("user " + id + " call get()");
              return serv.listAccount.at(index).visitor;
          }
              
          else {
              logger.information("user " + id + " call getTotal()");
              return serv.totalVisitor;
          }
      }
          
      else {
          logger.information("get user " + id + " error: Id not found!");
          return nul;
      }
  }

  bool inc(const std::string& id, const int num) {
    // Your implementation goes here
      int index = findAccountById(id);
      if (index != nul){
          serv.listAccount.at(index).visitor+=num;
          
          serv.totalVisitor+=num;
          
          return true;
          
      }
      else return false;
  }
  

};
Logger& CounterHandler::logger = Logger::get("TestLog");

class ServerApp: public Application {
private:
    bool _noop;
    bool _startServerRequested;
    int port;
    int workerCount;
    int serverType;
    AutoPtr<PropertyFileConfiguration> pConf;
    
public:
    ServerApp(){
        //constructor
        _noop = true;
        _startServerRequested = false;
        port = 3333;
        workerCount = 4;
        serverType = 0;        
        
        pConf = (new PropertyFileConfiguration("app.properties"));
        port = pConf->getInt("port", 3333);
        workerCount = pConf->getInt("worker", 4);
        serverType = pConf->getInt("type", 0);
        
        //init logger
        AutoPtr<FileChannel> pChanel(new FileChannel);
        AutoPtr<PatternFormatter> pPF (new PatternFormatter);
        pChanel->setProperty("path", "log/Log");
        pChanel->setProperty("rotation", "2 M");
        pChanel->setProperty("archive", "timestamp");
        pChanel->setProperty("times", "utc");
        pPF->setProperty("pattern", "%Y-%m-%d %H:%M:%S  %t");
        AutoPtr<FormattingChannel> pFC (new FormattingChannel(pPF, pChanel));

        CounterHandler::logger.setChannel(pFC);
    }
    
protected:
    void initialize(Application& self){
        loadConfiguration();
        //cout<<self.config().getInt("port",0)<<endl;
//        port = self.config().getInt("port", 3333);
//        workerCount = self.config().getInt("worker", 4);
//        serverType = self.config().getInt("type", 0);
        
        Application::initialize(self);
    }
    
    void uninitialize(){
        Application::uninitialize();
    }
    
    void reinitialize(Application& self){
        Application::reinitialize(self);
    }
    
    void defineOptions(OptionSet& options){
        Application::defineOptions(options);
        options.addOption(
            Option("help", "h", "display help information")
                .required(false)
                .repeatable(false)
                .callback(OptionCallback<ServerApp>(this, &ServerApp::handleHelp)));
        
        options.addOption(
            Option("port", "p", "change server port")
                .required(false)
                .repeatable(false)
                .argument("portnum")
                .validator(new IntValidator(2000, 9999))
                .callback(OptionCallback<ServerApp>(this, &ServerApp::handleDefine)));
        
        options.addOption(
            Option("type", "t", "change server type")
                .required(false)
                .repeatable(false)
                .argument("type")
                .validator(new IntValidator(0, 2))
                .callback(OptionCallback<ServerApp>(this, &ServerApp::handleDefine)));
        
        options.addOption(
            Option("worker", "w", "change number of worker")
                .required(false)
                .repeatable(false)
                .argument("num")
                .validator(new IntValidator(1, 5))
                .callback(OptionCallback<ServerApp>(this, &ServerApp::handleDefine)));
        
        options.addOption(
            Option("start", "s", "start server")
                .required(false)
                .repeatable(false)
                .callback(OptionCallback<ServerApp>(this, &ServerApp::handleStart)));
        
        
    }
    
    void handleHelp(const std::string& name, const std::string& value){
        _noop = false;
        displayHelp();
        stopOptionsProcessing();
    }
    
    void displayHelp(){
        HelpFormatter helpFormatter(options());
        helpFormatter.setCommand(commandName());
        helpFormatter.setUsage("OPTIONS");
        helpFormatter.setHeader("View Count Server options");
        helpFormatter.format(std::cout);
    }
    
    void handleDefine(const std::string& name, const std::string& value){
        _noop = false;
        if (name.compare("port") == 0 || name.compare("p") == 0){
            
            pConf->setString("port", value);
            CounterHandler::logger.information("change port to " + value);
            //return;
        }
        
        else if (name.compare("type") == 0 || name.compare("t") == 0){
            pConf->setString("type", value);
            CounterHandler::logger.information("change server type to " + value);
            //return;
        }
        
        else if (name.compare("worker") == 0 || name.compare("w") == 0){
            pConf->setString("worker", value);
            CounterHandler::logger.information("change number of worker to " + value);
            //return;
        }
        
        pConf->save("app.properties");
        
        
    }
    
    void handleStart(const std::string& name, const std::string& value){
        loadConfiguration();
        //cout<<this->config().getInt("port", 0)<<endl;
        _startServerRequested = true;
    }
    
    void startServer(){
        shared_ptr<CounterHandler> handler(new CounterHandler());
        shared_ptr<TProcessor> processor(new CounterProcessor(handler));
        shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
        shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
        shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

        //cout <<port<<"\t"<<serverType<<"\t"<<workerCount<<endl;

        switch (serverType%3){
            case 0:
                startSimpleServer(processor, serverTransport, transportFactory, protocolFactory);
                break;
            case 1:
                startThreadPoolServer(processor, serverTransport, transportFactory, protocolFactory);
                break;
            case 2:
                startThreadedServer(processor, serverTransport, transportFactory, protocolFactory);
                break;
            default:
                //cout<<"nothing done"<<endl;
                break;

        }
    }
    
    void startSimpleServer(shared_ptr<TProcessor> processor,
                        shared_ptr<TServerTransport> serverTransport,
                        shared_ptr<TTransportFactory> transportFactory, 
                        shared_ptr<TProtocolFactory> protocolFactory){
        cout<<"Simple Server started at port "<< port<<"...\n";
        CounterHandler::logger.information("Simple Server starts at port " + boost::lexical_cast<string>(port) + "...");

        TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

        server.serve();

    }

    void startThreadPoolServer(shared_ptr<TProcessor> processor,
                            shared_ptr<TServerTransport> serverTransport,
                            shared_ptr<TTransportFactory> transportFactory, 
                            shared_ptr<TProtocolFactory> protocolFactory){
          /**
       * Or you could do one of these*/
        cout<<"Thread Pool Server starts at port "<<port<<" ...\n";
        CounterHandler::logger.information("Thread Pool Server starts at port " + boost::lexical_cast<string>(port) + "...");

      shared_ptr<ThreadManager> threadManager =
        ThreadManager::newSimpleThreadManager(workerCount);
      shared_ptr<PosixThreadFactory> threadFactory =
            shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
      threadManager->threadFactory(threadFactory);
      threadManager->start();
      TThreadPoolServer server(processor,
                               serverTransport,
                               transportFactory,
                               protocolFactory,
                               threadManager);

      
      server.serve();
      

    }

    void startThreadedServer(shared_ptr<TProcessor> processor,
                            shared_ptr<TServerTransport> serverTransport,
                            shared_ptr<TTransportFactory> transportFactory, 
                            shared_ptr<TProtocolFactory> protocolFactory){

    cout<<"Threaded Server starts at port "<<port<<" ...\n";
    CounterHandler::logger.information("Threaded Server starts at port " + boost::lexical_cast<string>(port) + "...");
      shared_ptr<ThreadManager> threadManager =
        ThreadManager::newSimpleThreadManager(workerCount);
      shared_ptr<PosixThreadFactory> threadFactory =
            shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
      threadManager->threadFactory(threadFactory);
      threadManager->start();  

      TThreadedServer server(processor,
                             serverTransport,
                             transportFactory,
                             protocolFactory);

      server.serve();

    }
    
    int main(const std::vector<std::string>& args ){
        if (_startServerRequested){
            startServer();
        }
        
        if (_noop)
            displayHelp();
        
        return Application::EXIT_OK;
    }
    
};

POCO_APP_MAIN(ServerApp)



